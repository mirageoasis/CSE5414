/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "cal.h"
#include <stdbool.h>
#define MAXSIZE 256

void caleprog_1(char *host)
{
	CLIENT *clnt;
	int *result_1;
	int add_1_first = 4;
	int add_1_second = 5;
	int *result_2;
	int sub_1_first;
	int sub_1_second;
	int *result_3;
	int mul_1_first;
	int mul_1_second;
	int *result_4;
	int div_1_first = 4;
	int div_1_second = 4;
	int *result_5;
	int pow_1_first;
	int pow_1_second;

#ifndef DEBUG
	clnt = clnt_create(host, CALEPROG, CALMESSAGEVERS, "udp");
	if (clnt == NULL)
	{
		clnt_pcreateerror(host);
		exit(1);
	}
#endif /* DEBUG */
	add_1(0, 0, clnt);
	result_1 = add_1(add_1_first, add_1_second, clnt);
	fprintf(stdout, "%d\n", *result_1);
	if (result_1 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_2 = sub_1(sub_1_first, sub_1_second, clnt);
	if (result_2 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_3 = mul_1(mul_1_first, mul_1_second, clnt);
	if (result_3 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_4 = div_1(div_1_first, div_1_second, clnt);
	if (result_4 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_5 = pow_1(pow_1_first, pow_1_second, clnt);
	if (result_5 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
#ifndef DEBUG
	clnt_destroy(clnt);
#endif /* DEBUG */
}

typedef struct Node
{
	int data;
	// -1 plus
	// -2 sub
	// -3 div
	// -4 mul
	// -5 pow
	struct Node *next;
} Node;

typedef struct
{
	Node *top; // top pointer 선언
} Stack;

Node *buffer_list_head = NULL; // 처음에 buffer 에서 연산을 받아서 리스트로 만들어준다.
Node *buffer_list_tail = NULL; // 처음에 buffer 에서 연산을 받아서 리스트로 만들어준다.

Node *ans_list_head = NULL; // 후위연산 list
Node *ans_list_tail = NULL; // 후위연산 list


void buffer_list_add(int value)
{

	Node *pnew = (Node *)malloc(sizeof(Node));
	pnew->data = value;
	pnew->next = NULL;
	// 노드 값 설정

	if (buffer_list_head == NULL)
	{
		// 아무것도 없는 경우
		buffer_list_head = pnew;
		buffer_list_tail = pnew;
	}
	else
	{
		// 일반적인 경우
		buffer_list_tail->next = pnew;
		buffer_list_tail = pnew;
	}
}

void ans_list_add(int value)
{

	Node *pnew = (Node *)malloc(sizeof(Node));
	pnew->data = value;
	pnew->next = NULL;
	// 노드 값 설정

	if (ans_list_head == NULL)
	{
		// 아무것도 없는 경우
		ans_list_head = pnew;
		ans_list_tail = pnew;
	}
	else
	{
		// 일반적인 경우
		ans_list_tail->next = pnew;
		ans_list_tail = pnew;
	}
}

bool isPriority(int fromStack, int challenger){
	
	
	return false;
}

int getTop(Stack *stack) {
  Node *top = stack->top;
  return top->data;
}

void push(Stack *stack, int data) {
  Node *node = (Node*)malloc(sizeof(Node)); 
  node->data = data;
  node->next = stack->top;
  stack->top = node;
}

int pop(Stack *stack)
{
	if (stack->top == NULL)
	{
		printf("스택 언더플로우가 발생했습니다.\n");
		exit(1);
	}
	Node *node = stack->top;
	int data = node->data;
	stack->top = node->next;
	free(node);
	return data;
}

void list_construct(char * buffer){
	int mul_count = 0;
	int num_count = 0; // 숫자인지 아닌지 판별
	int num_stack = 0; // 숫자 남았는지 계산

	for (int i = 0; i < strlen(buffer) - 1; i++)
	{
		char c = buffer[i];
		// printf("%c ", buffer[i]);
		// printf("%d ", i);
		//  문자열 읽기
		switch (c)
		{
		case '+':
			buffer_list_add(num_stack);
			//printf("number\n");
			buffer_list_add(-1);
			mul_count = 0;
			num_count = 0;
			num_stack = 0;
			//printf("plus\n");
			break;
		case '-':
			buffer_list_add(num_stack);
			//printf("number\n");
			buffer_list_add(-2);
			mul_count = 0;
			num_count = 0;
			num_stack = 0;
			//printf("sub\n");
			break;
		case '/':
			buffer_list_add(num_stack);
			//printf("number\n");
			buffer_list_add(-3);
			mul_count = 0;
			num_count = 0;
			num_stack = 0;
			//printf("div\n");
			break;
		case '*':
			if (mul_count)
			{
				// ** 연산
				buffer_list_add(-5);
				//printf("pow\n");
			}else{
				buffer_list_add(num_stack);
				//printf("number\n");
			}
			mul_count ^= 1;
			num_count = 0;
			num_stack = 0;
			break;
		default:
			if (mul_count)
			{ // 전에 나온 문자가 곱셈이다.
				// 곱셈 연산
				buffer_list_add(-4);
				//printf("mul\n");
			}
			num_stack *= 10;
			num_stack += buffer[i] - '0';

			// printf("number\n");
			mul_count = 0;
			break;
		}
	}

	buffer_list_add(num_stack);
	//printf("number\n");
}

void postfix_construct(Node * cur){
	Stack temp_stack; // stack 이다.
	temp_stack.top = NULL;
	
	while (cur != NULL)
	{
		if (cur->data > -1)
		{ // 숫자다
			//fprintf(stdout, "%d", cur->data);
			ans_list_add(cur->data); // list 에 추가해준다.
		}
		else
		{
			// 연산자
			// -1 을 해주면 0 1 2 3 4 이런식임
			// 2로 나눠주면 연산자 우선순위도 만족~
			// 클수록 연산자 우선 순위가 크다고 약속
			int cal_id = abs(cur->data) - 1;
			int priority = cal_id / 2;
			
			// 스택이 비어있지 않을 때 AND TEMP_STACK.TOP
			while(temp_stack.top != NULL && priority < (abs(getTop(&temp_stack)) - 1) / 2){
				ans_list_add(pop(&temp_stack));
			}
			push(&temp_stack, cur->data);	
		}
	 	Node* prev = cur;
		//free(prev);
		cur = cur->next;
	}
	
	while (temp_stack.top != NULL) {
    	ans_list_add(pop(&temp_stack));
  	}

}

void debug_list(Node* cur){
	while(cur != NULL){
			//printf("%d ", count);
			if (cur->data > -1){
				fprintf(stdout, "%d ", cur->data);
			}else{
				switch(cur->data){
					case -1:
						fprintf(stdout, "+ ");
						break;
					case -2:
						fprintf(stdout, "- ");
						break;
					case -3:
						fprintf(stdout, "/ ");
						break;
					case -4:
						fprintf(stdout, "* ");
						break;
					case -5:
						fprintf(stdout, "** ");
						break;
				}
			//fprintf(stdout, "\n");
			}
			cur = cur->next;
		}
		fprintf(stdout, "\n");
}

void calculate(CLIENT *clnt){
	Stack temp_stack; // stack 이다.
	temp_stack.top = NULL;
	Node *cur = ans_list_head;

	while(cur != NULL){		
		if(cur->data > -1){ // 피연산자
			push(&temp_stack, cur->data);
		}else{ // 연산자
			int later = pop(&temp_stack);
			int earlier = pop(&temp_stack);
			int* result;
			switch (cur->data)
			{
			case -1:
				/* code */
				result = add_1(earlier, later, clnt);
				//fprintf(stdout, "%d\n", *result);
				if (result == (int *)NULL)
				{
					clnt_perror(clnt, "call failed");
				}
				break;
			case -2:
				/* code */
				result = sub_1(earlier, later, clnt);
				//fprintf(stdout, "%d\n", *result);
				if (result == (int *)NULL)
				{
					clnt_perror(clnt, "call failed");
				}
				break;
			case -3:
				/* code */
				result = div_1(earlier, later, clnt);
				//fprintf(stdout, "%d\n", *result);
				if (result == (int *)NULL)
				{
					clnt_perror(clnt, "call failed");
				}
				break;
			case -4:
				/* code */
				result = mul_1(earlier, later, clnt);
				//fprintf(stdout, "%d\n", *result);
				if (result == (int *)NULL)
				{
					clnt_perror(clnt, "call failed");
				}
				break;
			case -5:
				/* code */
				//fprintf(stdout, "%d %d\n", earlier, later);		
				result = pow_1(earlier, later, clnt);
				//fprintf(stdout, "%d\n", *result);
				if (result == (int *)NULL)
				{
					clnt_perror(clnt, "call failed");
				}
				break;
			default:
				fprintf(stdout, "오류 발생 마지막에서 발생!\n");
				exit(1);
				break;
			}
			// 결과를 다시 stack 에 push
			push(&temp_stack, *result);
		}
		cur = cur->next;
	}
	int final_result = pop(&temp_stack);

	printf("The answer is %d\n", final_result);
}

void free_list(Node * cur){
	while(cur != NULL){
	 	Node* prev= cur;
		cur = cur->next;
		free(prev);
	}
}

int main(int argc, char *argv[])
{
	char *host;

	if (argc < 2)
	{
		printf("usage: %s server_host\n", argv[0]);
		exit(1);
	}

	// host 받아오기
	host = argv[1];
	// caleprog_1 (host);

	char buffer[MAXSIZE + 1];
	// 연산 먼저하기
	fgets(buffer, MAXSIZE, stdin);
	// printf("%s\n", buffer);
	//  argument list 만들기

	list_construct(buffer);
	//debug_list(buffer_list_head);
	postfix_construct(buffer_list_head);
	free_list(buffer_list_head);

	//debug_list(ans_list_head);

	CLIENT *clnt;
	clnt = clnt_create(host, CALEPROG, CALMESSAGEVERS, "udp");
	if (clnt == NULL)
	{
		clnt_pcreateerror(host);
		exit(1);
	}
	
	calculate(clnt);

	// 연산 문자열 받아주기
	free_list(ans_list_head);
	clnt_destroy(clnt);
	exit(0);
}